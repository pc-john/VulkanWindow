#pragma once

#include <vulkan/vulkan.hpp>
#include <functional>
#include <bitset>



class VulkanWindow {
public:

	// general function prototypes
	typedef void FrameCallback(VulkanWindow& window);
	typedef void RecreateSwapchainCallback(VulkanWindow& window,
		const vk::SurfaceCapabilitiesKHR& surfaceCapabilities, vk::Extent2D newSurfaceExtent);
	typedef void CloseCallback(VulkanWindow& window);

	// input structures and enums
	struct MouseButton {
		enum EnumType {
			Left,
			Right,
			Middle,
			X1,
			X2,
			Unknown = 0xff,
		};
	};
	enum class ButtonState : uint8_t { Pressed, Released };
	enum class KeyState : uint8_t { Pressed, Released };
	struct Modifier {
		enum EnumType {
			Ctrl,
			Shift,
			Alt,
			Meta,
		};
	};
	struct MouseState {
		int posX, posY;  // position of the mouse in window client area coordinates (relative to the upper-left corner)
		int relX, relY;  // relative against the state of previous mouse callback
		std::bitset<16> buttons;
		std::bitset<16> mods;
	};
	enum class ScanCode : uint16_t {
		Unknown = 0, Escape = 1,
		Num1 = 2, Num2 = 3, Num3 = 4, Num4 = 5, Num5 = 6, Num6 = 7, Num7 = 8, Num8 = 9, Num9 = 10,
		Num0 = 11, Minus = 12, Equal = 13, Backspace = 14, Tab = 15, Q = 16, W = 17, E = 18, R = 19,
		T = 20, Y = 21, U = 22, I = 23, O = 24, P = 25, LeftBracket = 26, RightBracket = 27, Enter = 28, Return = 28, LeftControl = 29,
		A = 30, S = 31, D = 32, F = 33, G = 34, H = 35, J = 36, K = 37, L = 38, Semicolon = 39,
		Apostrophe = 40, GraveAccent = 41, LeftShift = 42, Backslash = 43, Z = 44, X = 45, C = 46, V = 47, B = 48, N = 49,
		M = 50, Comma = 51, Period = 52, Slash = 53, RightShift = 54, KeypadMultiply = 55, LeftAlt = 56, Space = 57, CapsLock = 58,
		F1 = 59, F2 = 60, F3 = 61, F4 = 62, F5 = 63, F6 = 64, F7 = 65, F8 = 66, F9 = 67, F10 = 68, NumLock = 69, NumLockClear = 69,
		ScrollLock = 70, Keypad7 = 71, Keypad8 = 72, Keypad9 = 73, KeypadMinus = 74, Keypad4 = 75, Keypad5 = 76, Keypad6 = 77, KeypadPlus = 78, Keypad1 = 79,
		Keypad2 = 80, Keypad3 = 81, Keypad0 = 82, KeypadPeriod = 83, /* Unknown, */ /* Unknown, */ NonUSBackslash = 86, F11 = 87, F12 = 88,

		KeypadEnter = 96, RightControl = 97, KeypadDivide = 98, PrintScreen = 99, RightAlt = 100 /* RightAlt might be configured as AltGr. In that case, LeftControl press is generated by RightAlt as well. To change AltGr to Alt, switch to US-English keyboard layout. */,
		Home = 102, Up = 103, PageUp = 104, Left = 105, Right = 106, End = 107, Down = 108, PageDown = 109, Insert = 110, Delete = 111,
		Mute = 113, VolumeDown = 114, VolumeUp = 115,
		PauseBreak = 119 /* na Xlib */,
		LeftGUI = 125, RightGUI = 126 /* untested */, Application = 127,
		Calculator = 140,
		LaunchMail = 155,
		AudioNext = 163, AudioPlay = 164, AudioPrev = 165, AudioStop = 166,
		LaunchMedia = 171, BrowserHome = 172,
		Search = 217,
		/* další: 99(xlib) na printscreen */

#if 0
		Unknown = 0x00, A = 0x04, B = 0x05, C = 0x06, D = 0x07,
		E = 0x08, F = 0x09, G = 0x0A, H = 0x0B, I = 0x0C, J = 0x0D, K = 0x0E, L = 0x0F,
		M = 0x10, N = 0x11, O = 0x12, P = 0x13, Q = 0x14, R = 0x15, S = 0x16, T = 0x17,
		U = 0x18, V = 0x19, W = 0x1A, X = 0x1B, Y = 0x1C, Z = 0x1D, Num1 = 0x1E, Num2 = 0x1F,
		Num3 = 0x20, Num4 = 0x21, Num5 = 0x22, Num6 = 0x23, Num7 = 0x24, Num8 = 0x25, Num9 = 0x26, Num0 = 0x27,
		Enter = 0x28, Return = 0x28, Escape = 0x29, Backspace = 0x2A, Tab = 0x2B,
		Space = 0x2C, Minus = 0x2D, Equal = 0x2E, LeftBracket = 0x2F, RightBracket = 0x30, Backslash = 0x31,
		NonUSHash = 0x32 /* ISO USB keyboards use this code instead of 0x31, but all OSes probably treat the two codes in the same way */,
		Semicolon = 0x33, Apostrophe = 0x34,
		Grave = 0x35 /* produces grave accent and tilde in a US Windows layout */,
		Comma = 0x36, Period = 0x37, Slash = 0x38, CapsLock = 0x39,
		F1 = 0x3A, F2 = 0x3B, F3 = 0x3C, F4 = 0x3D, F5 = 0x3E, F6 = 0x3F, F7 = 0x40, F8 = 0x41,
		F9 = 0x42, F10 = 0x43, F11 = 0x44, F12 = 0x45, PrintScreen = 0x46, ScrollLock = 0x47,
		Pause = 0x48, Insert = 0x49, Home = 0x4A, PageUp = 0x4B,
		Delete = 0x4C, End = 0x4D, PageDown = 0x4E, Right = 0x4F,
		Left = 0x50, Down = 0x51, Up = 0x52, NumLock = 0x53, NumLockClear = 0x53 /* num lock on PC, clear on Mac keyboards */,
		KP_Divide = 0x54, KP_Multiply = 0x55, KP_Minus = 0x56, KP_Plus = 0x57,
		KP_Enter = 0x58, KP_1 = 0x59, KP_2 = 0x5A, KP_3 = 0x5B, KP_4 = 0x5C, KP_5 = 0x5D,
		KP6 = 0x5E, KP7 = 0x5F, KP_8 = 0x60, KP_9 = 0x61, KP_0 = 0x62, KP_Period = 0x63,
		NonUSBackslash = 0x64 /* additional key on ISO USB keyboards between left shift and Y */,
		Application = 0x65, Power = 0x66, KP_Equal = 0x67,
		F13 = 0x68, F14 = 0x69, F15 = 0x6A, F16 = 0x6B, F17 = 0x6C, F18 = 0x6D, F19 = 0x6E, F20 = 0x6F,
		F21 = 0x70, F22 = 0x71, F23 = 0x72, F24 = 0x73, Execute = 0x74, Help = 0x75, Menu = 0x76, Select = 0x77,
		Stop = 0x78, Again = 0x79, Undo = 0x7A, Cut = 0x7B, Copy = 0x7C, Paste = 0x7D, Find = 0x7E, Mute = 0x7F,
		VolumeUp = 0x80, VolumeDown = 0x81, KP_Comma = 0x85, KP_EqualAS400 = 0x86 /* used on AS/400 keyboards */,
		International1 = 0x87, International2 = 0x88, International3 = 0x89, International4 = 0x8A,
		International5 = 0x8B, International6 = 0x8C, International7 = 0x8D, International8 = 0x8E, International9 = 0x8F,
		Lang1 = 0x90, Lang2 = 0x91, Lang3 = 0x92, Lang4 = 0x93, Lang5 = 0x94, Lang6 = 0x95, Lang7 = 0x96, Lang8 = 0x97, Lang9 = 0x98,
		AlternateErase = 0x99, SysReq = 0x9A, Cancel = 0x9B, Clear = 0x9C, Prior = 0x9D, Return2 = 0x9E, Separator = 0x9F,
		Out = 0xA0, Oper = 0xA1, ClearAgain = 0xA2, CrSel = 0xA3, ExSel = 0xA4,
		KP_00 = 0xB0, KP_000 = 0xB1, ThousandsSeparator = 0xB2, DecimalSeparator = 0xB3, CurrencyUnit = 0xB4, CurrencySubunit = 0xB5,
		KP_LeftParen = 0xB6, KP_RightParen = 0xB7, KP_LeftBrace = 0xB8, KP_RightBrace = 0xB9,
		KP_Tab = 0xBA, KP_Backspace = 0xBB, KP_A = 0xBC, KP_B = 0xBD, KP_C = 0xBE, KP_D = 0xBF,
		KP_E = 0xC0, KP_F = 0xC1, KP_XOR = 0xC2, KP_Power = 0xC3, KP_Percent = 0xC4,
		KP_Less = 0xC5, KP_Greater = 0xC6, KP_Ampersand = 0xC7, KP_DblAmpersand = 0xC8,
		KP_VerticalBar = 0xC9, KP_DblVerticalBar = 0xCA, KP_Colon = 0xCB, KP_Hash = 0xCC, KP_Space = 0xCD,
		KP_At = 0xCE, KP_Exclam = 0xCF, KP_MemStore = 0xD0, KP_MemRecall = 0xD1, KP_MemClear = 0xD2, KP_MemAdd = 0xD3,
		KP_MemSubstract = 0xD4, KP_MemMultiply = 0xD5, KP_MemDivide = 0xD6, KP_PlusMinus = 0xD7, KP_Clear = 0xD8,
		KP_ClearEntry = 0xD9, KP_Binary = 0xDA, KP_Octal = 0xDB, KP_Decimal = 0xDC, KP_Hexadecimal = 0xDD,
		LeftControl = 0xE0, LeftShift = 0xE1, LeftAlt = 0xE2, LeftGUI = 0xE3, LeftMeta = 0xE3, LeftWinKey = 0xE3,
		RightControl = 0xE4, RightShift = 0xE5, RightAlt = 0xE6, RightGUI = 0xE7, RightMeta = 0xE7, RightWinKey = 0xE7,
#endif
	};

	// input function prototypes
	typedef void MouseMoveCallback(VulkanWindow& window, const MouseState& mouseState);
	typedef void MouseButtonCallback(VulkanWindow& window, MouseButton::EnumType button, ButtonState buttonState, const MouseState& mouseState);
	typedef void MouseWheelCallback(VulkanWindow& window, int wheelX, int wheelY, const MouseState& mouseState);
	typedef void KeyCallback(VulkanWindow& window, KeyState keyState, uint16_t scanCode, uint16_t keyCode);

protected:

#if defined(USE_PLATFORM_WIN32)

	void* _hwnd = nullptr;  // void* is used instead of HWND type to avoid #include <windows.h>
	enum class FramePendingState { NotPending, Pending, TentativePending };
	FramePendingState _framePendingState;
	bool _visible;
	bool _hiddenWindowFramePending;

	static inline void* _hInstance = 0;  // void* is used instead of HINSTANCE type to avoid #include <windows.h>
	static inline uint16_t _windowClass = 0;  // uint16_t is used instead of ATOM type to avoid #include <windows.h>
	static inline const std::vector<const char*> _requiredInstanceExtensions =
		{ "VK_KHR_surface", "VK_KHR_win32_surface" };

#elif defined(USE_PLATFORM_XLIB)

	unsigned long _window = 0;  // unsigned long is used for Window type
	bool _framePending;
	bool _visible;
	bool _fullyObscured;
	bool _iconVisible;
	bool _minimized;

	static inline struct _XDisplay* _display = nullptr;  // struct _XDisplay* is used instead of Display* type
	static inline unsigned long _wmDeleteMessage;  // unsigned long is used for Atom type
	static inline unsigned long _wmStateProperty;  // unsigned long is used for Atom type
	static inline const std::vector<const char*> _requiredInstanceExtensions =
		{ "VK_KHR_surface", "VK_KHR_xlib_surface" };

	void updateMinimized();

#elif defined(USE_PLATFORM_WAYLAND)

	// objects
	struct wl_surface* _wlSurface = nullptr;
	struct xdg_surface* _xdgSurface = nullptr;
	struct xdg_toplevel* _xdgTopLevel = nullptr;
	struct zxdg_toplevel_decoration_v1* _decoration = nullptr;
	struct wl_callback* _scheduledFrameCallback = nullptr;

	// wl and xdg listeners
	struct WaylandListeners* _listeners = nullptr;

	// state
	bool _forcedFrame;
	std::string _title;

	// globals
	static inline struct wl_display* _display = nullptr;
	static inline struct wl_registry* _registry;
	static inline struct wl_compositor* _compositor = nullptr;
	static inline struct xdg_wm_base* _xdgWmBase = nullptr;
	static inline struct zxdg_decoration_manager_v1* _zxdgDecorationManagerV1 = nullptr;
	static inline struct wl_seat* _seat = nullptr;
	static inline struct wl_pointer* _pointer = nullptr;
	static inline struct wl_keyboard* _keyboard = nullptr;
	static inline struct xkb_context* _xkbContext = nullptr;
	static inline struct xkb_state* _xkbState = nullptr;

	static inline const std::vector<const char*> _requiredInstanceExtensions =
		{ "VK_KHR_surface", "VK_KHR_wayland_surface" };

#elif defined(USE_PLATFORM_SDL2)

	struct SDL_Window* _window = nullptr;
	bool _framePending;
	bool _hiddenWindowFramePending;
	bool _visible;
	bool _minimized;

#elif defined(USE_PLATFORM_GLFW)

	struct GLFWwindow* _window = nullptr;
	enum class FramePendingState { NotPending, Pending, TentativePending };
	FramePendingState _framePendingState;
	bool _visible;
	bool _minimized;

#elif defined(USE_PLATFORM_QT)

	class QWindow* _window = nullptr;
	friend class QtRenderingWindow;

#endif

	std::function<FrameCallback> _frameCallback;
	vk::Instance _instance;
	vk::PhysicalDevice _physicalDevice;
	vk::Device _device;
	vk::SurfaceKHR _surface;

	vk::Extent2D _surfaceExtent = vk::Extent2D(0,0);
	bool _swapchainResizePending = true;
	std::function<RecreateSwapchainCallback> _recreateSwapchainCallback;
	std::function<CloseCallback> _closeCallback;

	MouseState _mouseState = {};
	std::function<MouseMoveCallback> _mouseMoveCallback;
	std::function<MouseButtonCallback> _mouseButtonCallback;
	std::function<MouseWheelCallback> _mouseWheelCallback;
	std::function<KeyCallback> _keyCallback;

public:

	// initialization and finalization
	static void init();
	static void init(void* data);
	static void init(int& argc, char* argv[]);
	static void finalize() noexcept;

	// construction and destruction
	VulkanWindow() = default;
	VulkanWindow(VulkanWindow&& other);
	~VulkanWindow();
	void destroy() noexcept;
	VulkanWindow& operator=(VulkanWindow&& rhs) noexcept;

	// deleted constructors and operators
	VulkanWindow(const VulkanWindow&) = delete;
	VulkanWindow& operator=(const VulkanWindow&) = delete;

	// general methods
	vk::SurfaceKHR create(vk::Instance instance, vk::Extent2D surfaceExtent, const char* title = "Vulkan window");
	void show();
	void hide();
	void setVisible(bool value);
	void renderFrame();
	static void mainLoop();
	static void exitMainLoop();

	// callbacks
	void setRecreateSwapchainCallback(std::function<RecreateSwapchainCallback>&& cb);
	void setRecreateSwapchainCallback(const std::function<RecreateSwapchainCallback>& cb);
	void setFrameCallback(std::function<FrameCallback>&& cb, vk::PhysicalDevice physicalDevice, vk::Device device);
	void setFrameCallback(const std::function<FrameCallback>& cb, vk::PhysicalDevice physicalDevice, vk::Device device);
	void setCloseCallback(std::function<CloseCallback>&& cb);
	void setCloseCallback(const std::function<CloseCallback>& cb);
	void setMouseMoveCallback(std::function<MouseMoveCallback>&& cb);
	void setMouseMoveCallback(const std::function<MouseMoveCallback>& cb);
	void setMouseButtonCallback(std::function<MouseButtonCallback>&& cb);
	void setMouseButtonCallback(const std::function<MouseButtonCallback>& cb);
	void setMouseWheelCallback(std::function<MouseWheelCallback>&& cb);
	void setMouseWheelCallback(const std::function<MouseWheelCallback>& cb);
	void setKeyCallback(std::function<KeyCallback>&& cb);
	void setKeyCallback(const std::function<KeyCallback>& cb);
	const std::function<RecreateSwapchainCallback>& recreateSwapchainCallback() const;
	const std::function<FrameCallback>& frameCallback() const;
	const std::function<CloseCallback>& closeCallback() const;
	const std::function<MouseMoveCallback>& mouseMoveCallback() const;
	const std::function<MouseButtonCallback>& mouseButtonCallback() const;
	const std::function<MouseWheelCallback>& mouseWheelCallback() const;
	const std::function<KeyCallback>& keyCallback() const;

	// getters
	vk::SurfaceKHR surface() const;
	vk::Extent2D surfaceExtent() const;
	bool isVisible() const;

	// schedule methods
	void scheduleFrame();
	void scheduleSwapchainResize();

	// exception handling
	static inline std::exception_ptr thrownException;

	// required Vulkan Instance extensions
	static const std::vector<const char*>& requiredExtensions();
	static std::vector<const char*>& appendRequiredExtensions(std::vector<const char*>& v);
	static uint32_t requiredExtensionCount();
	static const char* const* requiredExtensionNames();

};


// inline methods
inline void VulkanWindow::setVisible(bool value)  { if(value) show(); else hide(); }
inline void VulkanWindow::setRecreateSwapchainCallback(std::function<RecreateSwapchainCallback>&& cb)  { _recreateSwapchainCallback = move(cb); }
inline void VulkanWindow::setRecreateSwapchainCallback(const std::function<RecreateSwapchainCallback>& cb)  { _recreateSwapchainCallback = cb; }
inline void VulkanWindow::setFrameCallback(std::function<FrameCallback>&& cb, vk::PhysicalDevice physicalDevice, vk::Device device)  { _frameCallback = std::move(cb); _physicalDevice = physicalDevice; _device = device; }
inline void VulkanWindow::setFrameCallback(const std::function<FrameCallback>& cb, vk::PhysicalDevice physicalDevice, vk::Device device)  { _frameCallback = cb; _physicalDevice = physicalDevice; _device = device; }
inline void VulkanWindow::setCloseCallback(std::function<CloseCallback>&& cb)  { _closeCallback = move(cb); }
inline void VulkanWindow::setCloseCallback(const std::function<CloseCallback>& cb)  { _closeCallback = cb; }
inline void VulkanWindow::setMouseMoveCallback(std::function<MouseMoveCallback>&& cb)  { _mouseMoveCallback = move(cb); }
inline void VulkanWindow::setMouseMoveCallback(const std::function<MouseMoveCallback>& cb)  { _mouseMoveCallback = cb; }
inline void VulkanWindow::setMouseButtonCallback(std::function<MouseButtonCallback>&& cb)  { _mouseButtonCallback = move(cb); }
inline void VulkanWindow::setMouseButtonCallback(const std::function<MouseButtonCallback>& cb)  { _mouseButtonCallback = cb; }
inline void VulkanWindow::setMouseWheelCallback(std::function<MouseWheelCallback>&& cb)  { _mouseWheelCallback = move(cb); }
inline void VulkanWindow::setMouseWheelCallback(const std::function<MouseWheelCallback>& cb)  { _mouseWheelCallback = cb; }
inline void VulkanWindow::setKeyCallback(std::function<KeyCallback>&& cb)  { _keyCallback = move(cb); }
inline void VulkanWindow::setKeyCallback(const std::function<KeyCallback>& cb)  { _keyCallback = cb; }
inline const std::function<VulkanWindow::RecreateSwapchainCallback>& VulkanWindow::recreateSwapchainCallback() const  { return _recreateSwapchainCallback; }
inline const std::function<VulkanWindow::FrameCallback>& VulkanWindow::frameCallback() const  { return _frameCallback; }
inline const std::function<VulkanWindow::CloseCallback>& VulkanWindow::closeCallback() const  { return _closeCallback; }
inline const std::function<VulkanWindow::MouseMoveCallback>& VulkanWindow::mouseMoveCallback() const  { return _mouseMoveCallback; }
inline const std::function<VulkanWindow::MouseButtonCallback>& VulkanWindow::mouseButtonCallback() const  { return _mouseButtonCallback; }
inline const std::function<VulkanWindow::MouseWheelCallback>& VulkanWindow::mouseWheelCallback() const  { return _mouseWheelCallback; }
inline const std::function<VulkanWindow::KeyCallback>& VulkanWindow::keyCallback() const  { return _keyCallback; }
inline vk::SurfaceKHR VulkanWindow::surface() const  { return _surface; }
inline vk::Extent2D VulkanWindow::surfaceExtent() const  { return _surfaceExtent; }
#if defined(USE_PLATFORM_WIN32) || defined(USE_PLATFORM_XLIB) || defined(USE_PLATFORM_SDL2) || defined(USE_PLATFORM_GLFW)
inline bool VulkanWindow::isVisible() const  { return _visible; }
#elif defined(USE_PLATFORM_WAYLAND)
inline bool VulkanWindow::isVisible() const  { return _xdgSurface != nullptr; }
#endif
inline void VulkanWindow::scheduleSwapchainResize()  { _swapchainResizePending = true; scheduleFrame(); }
#if defined(USE_PLATFORM_WIN32) || defined(USE_PLATFORM_XLIB) || defined(USE_PLATFORM_WAYLAND)
inline const std::vector<const char*>& VulkanWindow::requiredExtensions()  { return _requiredInstanceExtensions; }
inline std::vector<const char*>& VulkanWindow::appendRequiredExtensions(std::vector<const char*>& v)  { v.insert(v.end(), _requiredInstanceExtensions.begin(), _requiredInstanceExtensions.end()); return v; }
inline uint32_t VulkanWindow::requiredExtensionCount()  { return uint32_t(_requiredInstanceExtensions.size()); }
inline const char* const* VulkanWindow::requiredExtensionNames()  { return _requiredInstanceExtensions.data(); }
#endif


// nifty counter / Schwarz counter
// (VulkanWindow::finalize() must be called after all VulkanWindow objects were destroyed.
// We are doing it using Nifty counter programming idiom.)
struct VulkanWindowInitAndFinalizer
{
	VulkanWindowInitAndFinalizer();
	~VulkanWindowInitAndFinalizer();
};
static VulkanWindowInitAndFinalizer vulkanWindowInitAndFinalizer;
